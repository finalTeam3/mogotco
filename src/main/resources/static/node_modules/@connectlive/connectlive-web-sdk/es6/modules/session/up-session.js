var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Session } from './session';
import { indexer } from '../../utils/indexer';
import { Loggable, logger } from '../../utils/logger';
import { ClientError, ServerError } from '../../utils/error-exception';
import userAgent from '../../utils/user-agent';
// @FIXME: event emit/on 시 name 규칙 정하기
export class UpSession extends Session {
    constructor(roomApiClient, config) {
        super(roomApiClient, 'up', config);
        this.streamIdMidMap = {};
        this.activeProfile = 'l';
        this.oldAudioStats = [];
        this.oldVideoStats = [];
        this.oldCandidatePair = null;
        this.addListeners();
    }
    /**
     * 송출 스트림 등록 요청 API. 송출 스트림은 Audio, Video 총 2개를 조합으로 요청할 수 있다.
     */
    addStream({ audioType, audioTrack, audioExtraValue, videoType, localVideo, videoExtraValue, videoHd, record }) {
        return new Promise((resolve, reject) => {
            const negotiationId = indexer.get().toString();
            this.emitter.once(negotiationId, (params) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if ('code' in params) {
                    logger.error('addStream', params);
                    const error = new ServerError(params.code, params.message);
                    return reject(error);
                }
                try {
                    const { desc: offer, audio: audioOffer, video: videoOffer } = params;
                    // 1. setRemoteDescription
                    yield this.peerConnection.setRemoteDescription(offer);
                    // 2. replace tracks
                    audioOffer && (yield this._replaceAudioTrack(audioOffer, audioTrack));
                    videoOffer && (yield this._replaceVideoTrack(videoOffer, localVideo));
                    // 3. createAnswer & setLocalDescription
                    const answer = yield this.peerConnection.createAnswer();
                    yield this.peerConnection.setLocalDescription(answer);
                    // 4. if multiple, set profiles equally
                    //if (videoOffer && videoOffer.type === 'multiple') {
                    if (videoOffer) {
                        this._setVideoProfiles(videoOffer);
                    }
                    // 5. call setAnswer
                    yield this._callSetAnswer({ negotiationId, desc: answer });
                    // 6. save streamId : mid data
                    // Q. type이 none일 때, streamId와 mid는 어떻게 나타날까?
                    if (audioOffer && audioOffer.type !== 'none') {
                        const prev = (_a = this.streamIdMidMap[audioOffer.streamId]) !== null && _a !== void 0 ? _a : {};
                        this.streamIdMidMap[audioOffer.streamId] = Object.assign(Object.assign({}, prev), { default: audioOffer.mid });
                    }
                    if (videoOffer && videoOffer.type !== 'none') {
                        videoOffer.profiles.forEach(p => {
                            var _a;
                            const prev = (_a = this.streamIdMidMap[videoOffer.streamId]) !== null && _a !== void 0 ? _a : {};
                            this.streamIdMidMap[videoOffer.streamId] = Object.assign(Object.assign({}, prev), { [p.profile]: p.mid });
                        });
                    }
                    // finally, resolve
                    resolve({ audioOffer, videoOffer });
                }
                catch (err) {
                    const e = err;
                    const message = e.message;
                    reject(new ClientError(1442, `스트림 추가 에러(${message})`, e));
                }
            }));
            try {
                this._callAddStream({
                    negotiationId,
                    audio: { type: audioType, extraValue: audioExtraValue },
                    video: { type: videoType, extraValue: videoExtraValue, hd: videoHd },
                    record
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    /**
     * 송출 스트림 속성 변경 API.
     */
    configureStream(streams) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._callConfigureStream({ streams });
        });
    }
    removeStream(streamIds) {
        return new Promise((resolve, reject) => {
            const negotiationId = indexer.get().toString();
            const streams = streamIds.map(streamId => ({ streamId }));
            this.emitter.once(negotiationId, (params) => __awaiter(this, void 0, void 0, function* () {
                if ('code' in params) {
                    logger.error('removeStream', params);
                    const error = new ServerError(params.code, params.message);
                    return reject(error);
                }
                try {
                    const { desc: offer } = params;
                    // 1. setRemoteDescription
                    yield this.peerConnection.setRemoteDescription(offer);
                    // 2. remove tracks
                    this._removeTracks(streamIds);
                    // 3. createAnswer & setLocalDescription
                    const answer = yield this.peerConnection.createAnswer();
                    yield this.peerConnection.setLocalDescription(answer);
                    // 4. call setAnswer
                    yield this._callSetAnswer({ negotiationId, desc: answer });
                    // finally, resolve
                    resolve();
                }
                catch (err) {
                    const e = err;
                    const message = e.message;
                    reject(new ClientError(1446, `스트림 제거 에러(${message})`, e));
                }
            }));
            try {
                this._callRemoveStream({ negotiationId, streams });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    addListeners() {
        this.jsonrpc.on('Room.OnOffer', notification => {
            const { params } = notification;
            this.emitter.emit(params.negotiationId, params);
        });
        this.jsonrpc.on('Room.OnError', notification => {
            const { params } = notification;
            if (params.negotiationId) {
                this.emitter.emit(params.negotiationId, params);
            }
        });
        this.jsonrpc.on('Room.OnMessage', notification => {
            const { params } = notification;
            this.emitter.emit(params.type, params.data);
        });
        this.jsonrpc.on('Room.OnProfile', notification => {
            const { params } = notification;
            this._replaceVideoProfiles(params.streams);
        });
    }
    _callAddStream(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.AddStream';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    _callSetAnswer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.SetAnswer';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    _callConfigureStream(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.ConfigureStream';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    _callRemoveStream(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.RemoveStream';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    _callSendMessage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.SendMessage';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    _replaceAudioTrack(audioOffer, audioTrack) {
        return __awaiter(this, void 0, void 0, function* () {
            const transceivers = this.peerConnection.getTransceivers();
            const audioTransceiver = transceivers.find(t => t.mid === audioOffer.mid);
            if (audioTrack && audioTransceiver) {
                yield audioTransceiver.sender.replaceTrack(audioTrack);
                audioTransceiver.direction = 'sendonly';
            }
        });
    }
    _replaceVideoTrack(videoOffer, localVideo) {
        return __awaiter(this, void 0, void 0, function* () {
            const transceivers = this.peerConnection.getTransceivers();
            for (const profile of videoOffer.profiles) {
                const videoTransceiver = transceivers.find(t => t.mid === profile.mid);
                if ((localVideo === null || localVideo === void 0 ? void 0 : localVideo.getMediaStreamTrack()) && videoTransceiver) {
                    const cloneTrack = localVideo._getCloneTrack();
                    yield videoTransceiver.sender.replaceTrack(cloneTrack);
                    videoTransceiver.direction = 'sendonly';
                }
            }
        });
    }
    /**
     * multiple video 스트림의 profile 활성화 상태 통지.
     * 활성화 상태의 기본은  l = 활성, m = 비활성, h = 비활성으로 한다.
     * 이후 "l"  profile을 제외하고("l" profile은 항상 활성 상태) 수신측의 profile 요청이 생기거나 없어져서 상태변경이 필요할때 통지한다.
     * 대역폭을 효율적으로 사용하기 위해 클라이언트는 이 상태 값에 Tranceiver의 송출상태를 동기화하여 관리한다.
     */
    _replaceVideoProfiles(streams) {
        const transceivers = this.peerConnection.getTransceivers();
        streams.forEach(stream => {
            stream.profiles.forEach(profile => {
                const videoTransceiver = transceivers.find(t => t.mid === profile.mid);
                if (videoTransceiver) {
                    const params = videoTransceiver.sender.getParameters();
                    params.encodings[0].active = profile.active;
                    videoTransceiver.sender.setParameters(params);
                    this.activeProfile = profile.profile;
                }
            });
        });
    }
    _removeTracks(streamIds) {
        const transceivers = this.peerConnection.getTransceivers();
        streamIds.forEach(streamId => {
            for (const name in this.streamIdMidMap[streamId]) {
                const mid = this.streamIdMidMap[streamId][name];
                const transceiver = transceivers.find(t => t.mid === mid);
                if (transceiver) {
                    this.peerConnection.removeTrack(transceiver.sender);
                    delete this.streamIdMidMap[streamId][name];
                }
            }
        });
    }
    /**
     * MultipleVideoStream의 경우 SDP Answer 생성 뒤
     * Transceiver.sender의 bitrate 파라미터를 OnOffer의 profiles내 정보와 동일하게 세팅해야 한다.
     */
    _setVideoProfiles(videoOffer) {
        var _a, _b, _c, _d;
        const transceivers = this.peerConnection.getTransceivers();
        for (const profile of videoOffer.profiles) {
            const videoTransceiver = transceivers.find(t => t.mid === profile.mid);
            if (videoTransceiver) {
                const params = videoTransceiver.sender.getParameters();
                const active = profile.active;
                const maxBitrate = Number(profile.bitrate);
                const maxFramerate = profile.profile === 'l' ? (_a = this.config.maxFramerate) === null || _a === void 0 ? void 0 : _a.l : profile.profile === 'm' ? (_b = this.config.maxFramerate) === null || _b === void 0 ? void 0 : _b.m : (_c = this.config.maxFramerate) === null || _c === void 0 ? void 0 : _c.h;
                //const scaleResolutionDownBy = profile.profile === 'l' ? 3.0 : profile.profile === 'm' ? 2.0 : undefined;
                if (userAgent.getBrowser().name === 'Safari') {
                    const settings = (_d = videoTransceiver.sender.track) === null || _d === void 0 ? void 0 : _d.getSettings();
                    if (settings === null || settings === void 0 ? void 0 : settings.width) {
                        const scaleResolutionDownBy = profile.profile === 'l' ? settings.width / 240 : profile.profile === 'm' ? settings.width / 480 : settings.width / 640;
                        // @ts-ignore
                        params.encodings = [{ active, maxBitrate, maxFramerate, scaleResolutionDownBy }];
                    }
                }
                else {
                    // @ts-ignore
                    params.encodings = [{ active, maxBitrate, maxFramerate }];
                }
                videoTransceiver.sender.setParameters(params);
                if (active) {
                    this.activeProfile = profile.profile;
                }
            }
        }
    }
    getStats() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transceivers = this.peerConnection.getTransceivers();
            const _audioStats = [];
            const _videoStats = [];
            let candidatePair = {};
            for (const t of transceivers) {
                const stats = yield t.sender.getStats();
                const item = {
                    mid: t.mid,
                    items: []
                };
                stats.forEach((stat) => {
                    item.items.push(stat);
                    if (stat.type === 'candidate-pair') {
                        candidatePair = stat;
                    }
                });
                if (((_a = t.sender.track) === null || _a === void 0 ? void 0 : _a.kind) === 'audio') {
                    _audioStats.push(item);
                }
                else {
                    _videoStats.push(item);
                }
            }
            const audioStats = [];
            _audioStats.forEach((item) => {
                const result = {
                    mid: item.mid,
                    mediaSource: null,
                    outboundRtp: null,
                    track: null
                };
                item.items.forEach((stat) => {
                    if (stat.type === 'media-source') {
                        result.mediaSource = stat;
                    }
                    else if (stat.type === 'outbound-rtp') {
                        result.outboundRtp = stat;
                    }
                    else if (stat.type === 'track') {
                        result.track = stat;
                    }
                });
                if (result.mediaSource && result.outboundRtp && result.track) {
                    audioStats.push(result);
                }
            });
            const videoStats = [];
            _videoStats.forEach((item) => {
                const result = {
                    mid: item.mid,
                    mediaSource: null,
                    outboundRtp: null,
                    track: null
                };
                item.items.forEach((stat) => {
                    if (stat.type === 'media-source') {
                        result.mediaSource = stat;
                    }
                    else if (stat.type === 'outbound-rtp') {
                        result.outboundRtp = stat;
                    }
                    else if (stat.type === 'track') {
                        result.track = stat;
                    }
                });
                if (result.mediaSource && result.outboundRtp && result.track) {
                    videoStats.push(result);
                }
            });
            return {
                audioStats,
                videoStats,
                candidatePair
            };
        });
    }
    _setOldAudioStats(stats) {
        this.oldAudioStats = stats;
    }
    _setOldVideoStats(stats) {
        this.oldVideoStats = stats;
    }
    _setOldCandidatePairStats(candidatePair) {
        this.oldCandidatePair = candidatePair;
    }
}
__decorate([
    Loggable('info')
], UpSession.prototype, "addStream", null);
__decorate([
    Loggable('info')
], UpSession.prototype, "configureStream", null);
__decorate([
    Loggable('info')
], UpSession.prototype, "removeStream", null);
__decorate([
    Loggable('info')
], UpSession.prototype, "addListeners", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_callAddStream", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_callSetAnswer", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_callConfigureStream", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_callRemoveStream", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_callSendMessage", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_replaceAudioTrack", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_replaceVideoTrack", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_replaceVideoProfiles", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_removeTracks", null);
__decorate([
    Loggable('debug')
], UpSession.prototype, "_setVideoProfiles", null);
