var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Session } from './session';
import { indexer } from '../../utils/indexer';
import { Loggable, logger } from '../../utils/logger';
import { ClientError, ServerError } from '../../utils/error-exception';
import { objectToArray } from '../../utils/object-util';
// NOTE: receiverId = transceiver.mid
export class DownSession extends Session {
    constructor(roomApiClient, config) {
        super(roomApiClient, 'down', config);
        this.receiverTrackMap = {};
        this.fixedAudioReceiver = []; //shared or exclusive
        this.audioTransceivers = []; //stats의 오디오 rtp와 비교하기 위한 변수
        this.oldAudioStats = [];
        this.oldVideoStats = [];
        this.oldCandidatePair = null;
        this.addListeners();
    }
    addListeners() {
        this.jsonrpc.on('Room.OnParticipantsInfo', notification => {
            const { params } = notification;
            this.emitter.emit('ChangedParticipantsInfo', params);
        });
        this.jsonrpc.on('Room.OnOffer', notification => {
            const { params } = notification;
            // @NOTE: negotiationId가 (system)인 경우는, addStream 호출과 상관없이 세션 생성하자마자 내려오는 이벤트이다
            this.emitter.emit(params.negotiationId, params);
        });
        this.jsonrpc.on('Room.OnError', notification => {
            const { params } = notification;
            if (params.negotiationId) {
                this.emitter.emit(params.negotiationId, params);
            }
        });
        this.jsonrpc.on('Room.OnMessage', notification => {
            const { params } = notification;
            this.emitter.emit(params.type, params.data);
        });
        this.jsonrpc.on('Room.OnStreamChanged', notification => {
            this.emitter.emit('StreamChanged', notification);
        });
        // 처음 room과 연결되면 OnOffer가 내려온다.
        // FIXME: event name 및 로직 위치 이동(addReceiver와 같은 부분이기 때문)
        this.emitter.on('(system)', (params) => __awaiter(this, void 0, void 0, function* () {
            const { negotiationId, receivers, desc: offer } = params;
            yield this.peerConnection.setRemoteDescription(offer);
            const answer = yield this.peerConnection.createAnswer();
            yield this.peerConnection.setLocalDescription(answer);
            yield this.callSetAnswer({ negotiationId, desc: answer });
            const transceivers = this.peerConnection.getTransceivers();
            this.receiverTrackMap = transceivers.reduce((receiverTrackMap, transceiver) => {
                const receiverId = transceiver.mid;
                if (receiverId) {
                    if (transceiver.receiver.track.kind === 'video') {
                        receiverTrackMap[receiverId] = transceiver.receiver.track;
                    }
                }
                return receiverTrackMap;
            }, {});
            this.audioTransceivers = transceivers.filter(receiverTrackMap => receiverTrackMap.receiver.track.kind === 'audio');
            this.fixedAudioReceiver = this.audioTransceivers.map(transceiver => transceiver.receiver);
            const payload = {
                name: 'init',
                receivers,
            };
            this.emitter.emit('UpdatedReceivers', payload);
        }));
    }
    getTrack(receiverId) {
        return this.receiverTrackMap[receiverId];
    }
    getTracks() {
        return objectToArray(this.receiverTrackMap);
    }
    addReceiver(receivers) {
        return new Promise((resolve, reject) => {
            const negotiationId = indexer.get().toString();
            this.emitter.once(negotiationId, (params) => __awaiter(this, void 0, void 0, function* () {
                if ('code' in params) {
                    logger.error('addReceiver', params);
                    const error = new ServerError(params.code, params.message);
                    return reject(error);
                }
                try {
                    const { receivers, desc: offer } = params;
                    yield this.peerConnection.setRemoteDescription(offer);
                    const answer = yield this.peerConnection.createAnswer();
                    yield this.peerConnection.setLocalDescription(answer);
                    yield this.callSetAnswer({ negotiationId, desc: answer });
                    // update receivers
                    const transceivers = this.peerConnection.getTransceivers();
                    transceivers.reduce((receiverTrackMap, transceiver) => {
                        const receiverId = transceiver.mid;
                        const addReceiver = receivers.find(receiver => receiver.receiverId === receiverId);
                        if (addReceiver) {
                            if (transceiver.receiver.track.kind === 'video') {
                                this.receiverTrackMap[addReceiver.receiverId] = transceiver.receiver.track;
                            }
                        }
                        return receiverTrackMap;
                    }, {});
                    const payload = {
                        name: 'add',
                        receivers,
                    };
                    this.emitter.emit('UpdatedReceivers', payload);
                    resolve();
                }
                catch (err) {
                    const e = err;
                    const message = e.message;
                    reject(new ClientError(1448, `리시버 추가 에러(${message})`, e));
                }
            }));
            try {
                this.callAddReceiver({ negotiationId, receivers });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    getFixedAudioReceiver() {
        return this.fixedAudioReceiver;
    }
    // TODO: 뭔가 어려워보이니 일단 두고보기
    // configureReceiver(){}
    // 실제로 사용되지 않는다.
    removeReceiver(receiverIds) {
        return new Promise((resolve, reject) => {
            const negotiationId = indexer.get().toString();
            const receivers = receiverIds.map(receiverId => ({ receiverId }));
            this.emitter.once(negotiationId, (params) => __awaiter(this, void 0, void 0, function* () {
                if ('code' in params) {
                    logger.error('removeReceiver', params);
                    const error = new ServerError(params.code, params.message);
                    return reject(error);
                }
                try {
                    const { receivers, desc: offer } = params;
                    yield this.peerConnection.setRemoteDescription(offer);
                    const answer = yield this.peerConnection.createAnswer();
                    yield this.peerConnection.setLocalDescription(answer);
                    yield this.callSetAnswer({ negotiationId, desc: answer });
                    const transceivers = this.peerConnection.getTransceivers();
                    this.receiverTrackMap = transceivers.reduce((receiverTrackMap, transceiver) => {
                        const receiverId = transceiver.mid;
                        if (receiverId) {
                            if (transceiver.receiver.track.kind === 'video') {
                                receiverTrackMap[receiverId] = transceiver.receiver.track;
                            }
                        }
                        return receiverTrackMap;
                    }, {});
                    const payload = {
                        name: 'remove',
                        receivers,
                    };
                    this.emitter.emit('UpdatedReceivers', payload);
                    resolve();
                }
                catch (err) {
                    const e = err;
                    const message = e.message;
                    reject(new ClientError(0, message, e));
                }
            }));
            try {
                this.callRemoveReceiver({ negotiationId, receivers });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    assignStream(receivers) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAssignStream({ receivers });
        });
    }
    configureReceiver(receivers) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._callConfigureReceiver({ receivers });
        });
    }
    callAddReceiver(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.AddReceiver';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    callRemoveReceiver(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.RemoveReceiver';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    callSetAnswer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.SetAnswer';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    callAssignStream(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.AssignStream';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    _callConfigureReceiver(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'Room.ConfigureReceiver';
            const result = yield this.jsonrpc.call(method, params);
            if ('error' in result) {
                throw new ServerError(result.error.code, result.error.message);
            }
            return result;
        });
    }
    getStats() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transceivers = this.peerConnection.getTransceivers();
            const _audioStats = [];
            const _videoStats = [];
            let candidatePair = {};
            for (const t of transceivers) {
                const stats = yield t.receiver.getStats();
                const item = {
                    mid: t.mid,
                    items: []
                };
                stats.forEach((stat) => {
                    item.items.push(stat);
                    if (stat.type === 'candidate-pair') {
                        candidatePair = stat;
                    }
                });
                if (((_a = t.receiver.track) === null || _a === void 0 ? void 0 : _a.kind) === 'audio') {
                    _audioStats.push(item);
                }
                else {
                    _videoStats.push(item);
                }
            }
            const audioStats = [];
            _audioStats.forEach((item) => {
                const result = {
                    mid: item.mid,
                    inboundRtp: null,
                    track: null
                };
                item.items.forEach((stat) => {
                    if (stat.type === 'inbound-rtp') {
                        result.inboundRtp = stat;
                    }
                    else if (stat.type === 'track') {
                        result.track = stat;
                    }
                });
                if (result.inboundRtp && result.track) {
                    audioStats.push(result);
                }
            });
            const videoStats = [];
            _videoStats.forEach((item) => {
                const result = {
                    mid: item.mid,
                    inboundRtp: null,
                    track: null
                };
                item.items.forEach((stat) => {
                    if (stat.type === 'inbound-rtp') {
                        result.inboundRtp = stat;
                    }
                    else if (stat.type === 'track') {
                        result.track = stat;
                    }
                });
                if (result.inboundRtp && result.track) {
                    videoStats.push(result);
                }
            });
            return {
                audioStats,
                videoStats,
                candidatePair
            };
        });
    }
    _setOldAudioStats(stats) {
        this.oldAudioStats = stats;
    }
    _setOldVideoStats(stats) {
        this.oldVideoStats = stats;
    }
    _setOldCandidatePairStats(candidatePair) {
        this.oldCandidatePair = candidatePair;
    }
}
__decorate([
    Loggable('info')
], DownSession.prototype, "addListeners", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "getTrack", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "getTracks", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "addReceiver", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "removeReceiver", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "assignStream", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "configureReceiver", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "callAddReceiver", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "callRemoveReceiver", null);
__decorate([
    Loggable('debug')
], DownSession.prototype, "callSetAnswer", null);
__decorate([
    Loggable('info')
], DownSession.prototype, "callAssignStream", null);
__decorate([
    Loggable('debug')
], DownSession.prototype, "_callConfigureReceiver", null);
