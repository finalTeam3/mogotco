var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import EventEmitter from 'eventemitter3';
import { JSONRpc } from '../../utils/json-rpc';
import { Loggable, logger } from '../../utils/logger';
import { noop } from '../../utils/noop';
import userAgentParser from '../../utils/user-agent';
import { ClientError } from '../../utils/error-exception';
const browser = userAgentParser.getBrowser();
export class Session {
    constructor(apiClient, direction, config) {
        this.restartIceInterval = -1;
        this.config = {
            cpuOveruseDetection: true,
            maxFramerate: {
                l: 10,
                m: 20,
                h: 30
            },
            voiceMode: true
        };
        this.emitter = new EventEmitter();
        this.jsonrpc = new JSONRpc();
        this.roomApiClient = apiClient;
        this.direction = direction;
        this.index = 0;
        Object.assign(this.config, config);
        this.jsonrpc.toStream = message => {
            if (this.dataChannel && this.dataChannel.readyState === 'open') {
                logger.trace(`[${this.direction}] [SEND]`, message);
                this.dataChannel.send(JSON.stringify(message));
            }
        };
    }
    create(rtcConfig) {
        return new Promise((resolve, reject) => {
            // TODO: 이벤트 네이밍 규칙적으로 설정하기
            this.emitter.once('SessionCreated', () => {
                resolve();
            });
            try {
                this.createPeerConnection(rtcConfig);
            }
            catch (err) {
                const e = err;
                reject(new ClientError(1401, 'PeerConnection 생성이 실패했습니다.', e));
            }
            try {
                this.createDataChannel();
            }
            catch (err) {
                const e = err;
                reject(new ClientError(1402, '데이터 채널 생성이 실패했습니다.', e));
            }
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.close();
            yield this.roomApiClient.sendDestroySession(this.direction, this.index);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            this.peerConnection.close();
            this.dataChannel.close();
        });
    }
    on(name, callback) {
        this.emitter.on(name, callback);
    }
    off(name, callback) {
        this.emitter.off(name, callback);
    }
    createPeerConnection(rtcConfig) {
        if (this.peerConnection)
            this.peerConnection.close();
        const _rtcConfig = Object.assign(Object.assign({}, rtcConfig), { bundlePolicy: 'max-bundle', iceTransportPolicy: 'all', rtcpMuxPolicy: 'require', iceCandidatePoolSize: 0, sdpSemantics: 'unified-plan', extmapAllowMixed: true });
        const opt = {
            mandatory: {},
            optional: [
                //{ googHighStartBitrate: 0 }, //실제로 의미가 있는가?
                //{ googPayloadPadding: true }, //추천하지 않음
                //{ googScreencastMinBitrate: 100 }, //의미없음
                { enableDscp: true }
            ]
        };
        if (this.config.cpuOveruseDetection) {
            opt.optional.push({ googCpuOveruseDetection: true });
            opt.optional.push({ googCpuOveruseEncodeUsage: true });
            opt.optional.push({ googCpuUnderuseThreshold: 55 });
            opt.optional.push({ googCpuOveruseThreshold: 85 });
        }
        else {
            opt.optional.push({ googCpuOveruseDetection: false });
        }
        if (!this.config.voiceMode) {
            opt.mandatory.googHighpassFilter = false;
            opt.mandatory.googEchoCancellation = false;
            opt.mandatory.googEchoCancellation2 = false;
            opt.mandatory.googAutoGainControl = false;
            opt.mandatory.googAutoGainControl2 = false;
            opt.mandatory.googNoiseSuppression = false;
            opt.mandatory.googNoiseSuppression2 = false;
            opt.mandatory.googTypingNoiseDetection = false;
            opt.mandatory.echoCancellation = false;
        }
        /* @ts-ignore */
        this.peerConnection = new RTCPeerConnection(_rtcConfig, opt);
        logger.debug(`[${this.direction}] peerConnection = ${JSON.stringify(_rtcConfig)}`);
        this.peerConnection.onicecandidate = ice => {
            if (ice.candidate) {
                //if(ice.candidate.candidate) {
                this.roomApiClient.sendAddCandidate(this.direction, this.index, ice.candidate);
                logger.debug(`[${this.direction}] candidate = ${JSON.stringify(ice.candidate)}`);
                //}
            }
        };
        this.peerConnection.onnegotiationneeded = () => __awaiter(this, void 0, void 0, function* () {
            logger.debug(`[${this.direction}] onnegotiationneeded`);
            try {
                const offer = yield this.peerConnection.createOffer();
                yield this.peerConnection.setLocalDescription(offer);
                logger.debug(`[${this.direction}] create offer = ${JSON.stringify(offer)}`);
                const res = yield this.roomApiClient.sendCreateSession(this.direction, this.index, offer);
                const answer = new RTCSessionDescription(res.result.desc);
                yield this.peerConnection.setRemoteDescription(answer);
                logger.debug(`[${this.direction}] receive answer = ${JSON.stringify(answer)}`);
            }
            catch (err) {
                const message = err.message;
                logger.error(`[${this.direction}] onnegotiationneeded = ${message}`);
            }
        });
        this.peerConnection.onconnectionstatechange = (event) => __awaiter(this, void 0, void 0, function* () {
            logger.debug(`[${this.direction}] onconnectionstatechange = ${event.target.connectionState}`);
            this._restartIceTimerStop();
            if (event.target.connectionState === 'disconnected') {
                this._restartIceTimerStart();
            }
            else if (event.target.connectionState === 'failed') {
                logger.error(`[${this.direction}] onconnectionstatechange = ${event.target.connectionState}`);
                //연결 실패
                this.emitter.emit('error', new ClientError(1411, 'PeerConnection 연결 상태가 failed 입니다.'));
            }
        });
        this.peerConnection.oniceconnectionstatechange = (event) => {
            logger.debug(`[${this.direction}] oniceconnectionstatechange = ${event.target.iceConnectionState}`);
            if (browser.name === 'Firefox') {
                this._restartIceTimerStop();
                if (event.target.iceConnectionState === 'disconnected') {
                    this._restartIceTimerStart();
                }
                else if (event.target.iceConnectionState === 'failed') {
                    logger.error(`[${this.direction}] onconnectionstatechange = ${event.target.iceConnectionState}`);
                    //연결 실패.
                    this.emitter.emit('error', new ClientError(1411, 'PeerConnection 연결 상태가 failed 입니다.'));
                }
            }
            ;
        };
        this.peerConnection.ontrack = noop;
    }
    createDataChannel() {
        if (this.dataChannel)
            this.dataChannel.close();
        this.dataChannel = this.peerConnection.createDataChannel(this.direction);
        this.dataChannel.onopen = () => {
            logger.debug(`[${this.direction}] dataChannel is opened`);
        };
        this.dataChannel.onclose = () => {
            logger.debug(`[${this.direction}] dataChannel is closed`);
        };
        this.dataChannel.onerror = (evt) => {
            let error = evt.error;
            logger.error(`[${this.direction}] dataChannel occurred error. reason=${JSON.stringify(error)}`);
        };
        this.dataChannel.onmessage = (event) => __awaiter(this, void 0, void 0, function* () {
            const message = yield new Response(event.data).text();
            logger.trace(`[${this.direction}] [RECEIVE] dataChannel.onmessage = ${message}`);
            this.jsonrpc.handleMessage(message);
        });
    }
    _restartIceTimerStart() {
        this.restartIceInterval = window.setInterval(() => {
            if (navigator.onLine) {
                this._restartIceTimerStop();
                this._restartIce();
            }
        }, 100);
    }
    _restartIceTimerStop() {
        window.clearInterval(this.restartIceInterval);
        this.restartIceInterval = -1;
    }
    _restartIce() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const offer = yield this.peerConnection.createOffer({ iceRestart: true });
                yield this.peerConnection.setLocalDescription(offer);
                logger.debug(`[${this.direction}](RestartICE) create offer = ${JSON.stringify(offer)}`);
                const res = yield this.roomApiClient.sendRestartIce(this.direction, this.index, offer);
                const answer = new RTCSessionDescription(res.result.desc);
                yield this.peerConnection.setRemoteDescription(answer);
                logger.debug(`[${this.direction}](RestartICE) receive answer = ${JSON.stringify(answer)}`);
            }
            catch (err) {
                const message = err.message;
                logger.error(`[${this.direction}](RestartICE) onconnectionstatechange = ${message}`);
            }
        });
    }
    getAllStats() {
        return __awaiter(this, void 0, void 0, function* () {
            const stats = yield this.peerConnection.getStats();
            const item = {};
            stats.forEach((stat) => {
                item[stat.id] = stat;
            });
            return item;
        });
    }
}
__decorate([
    Loggable('info')
], Session.prototype, "create", null);
__decorate([
    Loggable('info')
], Session.prototype, "destroy", null);
__decorate([
    Loggable('info')
], Session.prototype, "close", null);
__decorate([
    Loggable('info')
], Session.prototype, "createPeerConnection", null);
__decorate([
    Loggable('info')
], Session.prototype, "createDataChannel", null);
__decorate([
    Loggable('info')
], Session.prototype, "_restartIce", null);
