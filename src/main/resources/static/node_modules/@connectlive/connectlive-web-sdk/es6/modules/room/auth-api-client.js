var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PROVISIONING_API_VERSION, PROVISIONING_SERVER_URL } from '../../config';
import { hash } from '../../utils/hash';
import { HttpWithJSONRpc } from '../../utils/http-with-json-rpc';
import { Loggable, logger } from '../../utils/logger';
import { ClientError, ServerError } from '../../utils/error-exception';
export class AuthApiClient extends HttpWithJSONRpc {
    constructor() {
        super();
        this.setHeaders({ method: 'post', headers: { 'Content-Type': 'application/json' } });
    }
    authorize(authConfig, fingerprint = '') {
        const host = authConfig.endpoint || PROVISIONING_SERVER_URL;
        this.setHost(host);
        if (!('token' in authConfig))
            return this.internally(authConfig, fingerprint);
        else
            return this.externally(authConfig, fingerprint);
    }
    ;
    refreshToken(serviceId, oldToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'ExtendTTL';
            const params = { serviceId: serviceId, token: oldToken };
            const response = yield this.request({ method, params });
            if ('error' in response) {
                logger.error('refreshToken', response);
                const error = new ServerError(response.error.code, response.error.message);
                throw error;
            }
            const { result } = response;
            return result;
        });
    }
    ;
    internally(config, fingerprint) {
        return __awaiter(this, void 0, void 0, function* () {
            const { serviceId, serviceSecret } = config;
            const texts = serviceSecret.split(':');
            const serviceKey = texts[0];
            const secret = texts[1];
            if (!serviceId || !serviceKey || !secret) {
                throw new ClientError(1103, '인증을 위한 서비스 정보가 입력되지 않았습니다.');
            }
            const scheme = 'internal';
            const method = 'Provision';
            const firstParams = {
                scheme,
                serviceId,
                version: PROVISIONING_API_VERSION
            };
            const firstResponse = yield this.request({
                method,
                params: firstParams,
            });
            if ('result' in firstResponse) {
                logger.error('internally', firstResponse);
                throw new Error('Provisioning Failed');
            }
            if (!('data' in firstResponse.error)) {
                logger.error('internally', firstResponse);
                const error = new ServerError(firstResponse.error.code, firstResponse.error.message);
                throw error;
            }
            const { nonce } = firstResponse.error.data;
            const ha = yield hash([serviceId, serviceKey, secret].join(':'));
            const value = yield hash([ha, nonce].join(':'));
            const secondParams = {
                version: PROVISIONING_API_VERSION,
                serviceId,
                scheme,
                fingerprint,
                auth: {
                    nonce,
                    key: serviceKey,
                    value,
                },
            };
            const secondResponse = yield this.request({ method, params: secondParams });
            if ('error' in secondResponse) {
                logger.error('internally', secondResponse);
                const error = new ServerError(secondResponse.error.code, secondResponse.error.message);
                throw error;
            }
            const { result } = secondResponse;
            return result;
        });
    }
    ;
    externally(config, fingerprint) {
        return __awaiter(this, void 0, void 0, function* () {
            const { token, serviceId } = config;
            if (!serviceId || !token) {
                throw new ClientError(1103, '인증을 위한 서비스 정보가 입력되지 않았습니다.');
            }
            const scheme = 'external';
            const method = 'Provision';
            const params = {
                serviceId,
                scheme,
                fingerprint,
                auth: { value: token }
            };
            const response = yield this.request({ method, params });
            if ('error' in response) {
                logger.error('externally', response);
                const error = new ServerError(response.error.code, response.error.message);
                throw error;
            }
            const { result } = response;
            return result;
        });
    }
    ;
}
__decorate([
    Loggable('info')
], AuthApiClient.prototype, "authorize", null);
__decorate([
    Loggable('info')
], AuthApiClient.prototype, "refreshToken", null);
__decorate([
    Loggable('info')
], AuthApiClient.prototype, "internally", null);
__decorate([
    Loggable('info')
], AuthApiClient.prototype, "externally", null);
