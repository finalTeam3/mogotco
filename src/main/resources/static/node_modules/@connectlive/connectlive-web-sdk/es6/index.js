var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { AuthApiClient } from './modules/room/auth-api-client';
import { SDK_VERSION } from './config';
import { logger, loggerSender, Loggable } from './utils/logger';
import { Room } from './modules/room/room';
import { LocalAudio } from './modules/local/local-audio';
import { LocalVideo } from './modules/local/local-video';
import { LocalScreen } from './modules/local/local-screen';
import { LocalMedia } from './modules/local/local-media';
import EventEmitter from 'eventemitter3';
import userAgentParser from './utils/user-agent';
import { ClientError } from './utils/error-exception';
import { setStorage, getStorage } from './utils/storage';
;
class ConnectLive {
    constructor() {
        new ClientError(1901, 'ConnectLive로 부턱 직접 객체를 선언할 수 없습니다.');
    }
    static on(eventName, callback) {
        this.emitter.on(eventName, callback);
    }
    static _startAuthTimer() {
        if (this.authResponse) {
            const timeout = Math.floor(this.authResponse.ttl * 0.9 * 1000);
            let restTtl = timeout;
            const fn = () => __awaiter(this, void 0, void 0, function* () {
                if (this.authResponse) {
                    try {
                        const res = yield this.authApiClient.refreshToken(this.authConfig.serviceId, this.authResponse.token);
                        this.authResponse.token = res.token;
                        this.authResponse.ttl = res.ttl;
                        this._startAuthTimer();
                    }
                    catch (err) {
                        logger.error('token refresh error');
                        const timeout = 600000;
                        restTtl = restTtl - timeout;
                        if (restTtl < 0) {
                            this.emitter.emit('tokenRefreshError', err);
                        }
                        else {
                            this.emitter.emit('tokenRefreshWarning', err);
                            window.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                fn();
                            }), timeout);
                        }
                    }
                }
            });
            this.authRefreshTimer = window.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                fn();
            }), timeout);
        }
    }
    static signIn(authConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authRefreshTimer > -1) {
                this.signOut();
            }
            const fingerprint = getStorage('connectlive-fingerprint') || '';
            this.authConfig = authConfig;
            this.authResponse = yield this.authApiClient.authorize(authConfig, fingerprint);
            setStorage('connectlive-fingerprint', this.authResponse.fingerprint);
            this._startAuthTimer();
            yield loggerSender.createWebSocket(this.authResponse.cnl, this.authResponse.token);
            logger.info('[method][Function.signIn]', authConfig);
            const device = userAgentParser.getDevice();
            const engine = userAgentParser.getEngine();
            const os = userAgentParser.getOS();
            const browser = userAgentParser.getBrowser();
            const cpu = userAgentParser.getCPU();
            logger.debug('DEVICE TYPE =', device.type + ',', 'DEVICE VENDOR =', device.vendor + ',', 'DEVICE MODEL =', device.model + ',', 'ENGINE NAME =', engine.name + ',', 'ENGINE VERSION =', engine.version + ',', 'OS NAME =', os.name + ',', 'OS VERSION =', os.version + ',', 'BROWSER NAME =', browser.name + ',', 'BROWSER VERSION =', browser.version + ',', 'CPU =', cpu.architecture + ',', 'SDK VERSION =', SDK_VERSION);
            this.signStatus = "signin" /* SIGN_IN */;
        });
    }
    static signOut() {
        window.clearTimeout(this.authRefreshTimer);
        this.authRefreshTimer = -1;
        this.authResponse = null;
        this.signStatus = "signout" /* SIGN_OUT */;
        loggerSender.destroy();
    }
    static createLocalMedia(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            const localMedia = new LocalMedia(constraints || {});
            if (constraints) {
                yield localMedia._getUserMedia();
            }
            return localMedia;
        });
    }
    static createLocalScreen(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            const localScreen = new LocalScreen(constraints);
            yield localScreen._getDisplayMedia();
            return localScreen;
        });
    }
    static createRoom(config) {
        if (this.authResponse) {
            return new Room(this.authConfig, this.authResponse, config);
        }
        throw new ClientError(1106, '룸 생성 전 인증이 필요합니다.');
    }
}
ConnectLive.emitter = new EventEmitter();
ConnectLive.authApiClient = new AuthApiClient();
ConnectLive.authRefreshTimer = -1;
ConnectLive.signStatus = "signout" /* SIGN_OUT */;
ConnectLive.version = SDK_VERSION;
ConnectLive.logger = logger;
__decorate([
    Loggable('info')
], ConnectLive, "signOut", null);
__decorate([
    Loggable('info')
], ConnectLive, "createLocalMedia", null);
__decorate([
    Loggable('info')
], ConnectLive, "createLocalScreen", null);
__decorate([
    Loggable('info')
], ConnectLive, "createRoom", null);
export default ConnectLive;
