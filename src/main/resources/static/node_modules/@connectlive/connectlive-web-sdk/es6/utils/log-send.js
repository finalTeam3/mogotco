var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as jsonrpc from 'jsonrpc-lite';
import { indexer } from './indexer';
import userAgentParser from './user-agent';
import { CNL_API_VERSION, SDK_VERSION } from '../config';
import { delay } from './delay';
import ConnectLive from '../index';
const LogLevel = {
    verbose: 0,
    trace: 1,
    debug: 2,
    information: 3,
    warning: 4,
    error: 5
};
export class LogSender {
    constructor() {
        this.ws = null;
        this.keepAliveInterval = -1;
        this.host = '';
        this.token = '';
        this.logLevelNumber = 3;
        this.reconnectPeriod = -1;
        this.reconnectTimeGap = 1000;
        this.collectionPeriod = 5;
    }
    createWebSocket(host, token) {
        this.host = host;
        this.token = token;
        this.close();
        this.clearKeepAliveTimer();
        return new Promise((resolve) => {
            this.ws = new WebSocket(host);
            this.ws.onopen = () => {
                const os = userAgentParser.getOS();
                const browser = userAgentParser.getBrowser();
                const device = userAgentParser.getDevice();
                const method = 'CnL.Registration';
                const params = {
                    token: token,
                    userInfo: {
                        sdkVersion: SDK_VERSION,
                        platform: 'web',
                        platformVersion: `${browser.name}/${browser.version}`,
                        osName: os.name,
                        osVersion: os.version,
                        deviceModel: device.model || '',
                    }
                };
                this.send({ method, params });
                this.keepAliveInterval = window.setInterval(() => {
                    this.send({
                        method: 'CnL.KeepAlive',
                        params: {}
                    });
                }, 50000);
                resolve(true);
            };
            this.ws.onerror = () => {
                if (ConnectLive.signStatus === "signin" /* SIGN_IN */) {
                    this.reconnect();
                }
            };
            this.ws.onclose = () => {
                if (ConnectLive.signStatus === "signin" /* SIGN_IN */) {
                    this.reconnect();
                }
            };
            this.ws.onmessage = (evt) => {
                const data = JSON.parse(evt.data);
                if (data.method === 'CnL.Push') {
                    this.setLevel(data.params.config.log_level);
                }
                if (data.result) {
                    if (data.result.config) {
                        if (data.result.config.cnl) {
                            this.reconnectPeriod = data.result.config.cnl.reconnect_period;
                        }
                        if (data.result.config.quality_metrics) {
                            this.collectionPeriod = data.result.config.quality_metrics.collection_period;
                        }
                    }
                }
            };
        });
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.close();
            if (this.reconnectPeriod > -1) {
                yield delay(this.reconnectPeriod);
            }
            window.setTimeout(() => {
                this.createWebSocket(this.host, this.token);
            }, this.reconnectTimeGap);
            if (this.reconnectTimeGap >= 16000) {
                this.reconnectTimeGap = 16000;
            }
            else {
                this.reconnectTimeGap = this.reconnectTimeGap * 2;
            }
        });
    }
    send(body, isLog = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ws) {
                return;
            }
            const method = body.method;
            const params = body.params;
            params.version = CNL_API_VERSION;
            if (method === 'CnL.Log') {
                const level = params.logs[0].level;
                if (LogLevel[level] < this.logLevelNumber) {
                    return;
                }
            }
            const id = indexer.get().toString();
            let stringified = '';
            if (!isLog) {
                stringified = JSON.stringify(jsonrpc.request(id, method, params));
            }
            else {
                stringified = JSON.stringify(jsonrpc.notification(method, params));
            }
            if (this.ws.readyState !== this.ws.CONNECTING) {
                if (this.ws.readyState !== this.ws.CLOSED && this.ws.readyState !== this.ws.CLOSING) {
                    this.ws.send(stringified);
                }
            }
            else {
                const timer = window.setInterval(() => {
                    var _a, _b, _c;
                    if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === ((_b = this.ws) === null || _b === void 0 ? void 0 : _b.OPEN)) {
                        window.clearInterval(timer);
                        (_c = this.ws) === null || _c === void 0 ? void 0 : _c.send(stringified);
                    }
                }, 10);
            }
        });
    }
    clearKeepAliveTimer() {
        window.clearInterval(this.keepAliveInterval);
        this.keepAliveInterval = -1;
    }
    close() {
        var _a;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
        this.ws = null;
    }
    destroy() {
        this.close();
        this.clearKeepAliveTimer();
        this.logLevelNumber = 3;
        this.reconnectPeriod = -1;
        this.reconnectTimeGap = 1000;
    }
    setLevel(logLevel) {
        this.logLevelNumber = LogLevel[logLevel];
    }
}
