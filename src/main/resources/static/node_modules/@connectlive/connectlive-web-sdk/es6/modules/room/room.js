var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import EventEmitter from 'eventemitter3';
import { RoomApiClient } from './room-api-client';
import { DownSession } from '../session/down-session';
import { UpSession } from '../session/up-session';
import { logger, Loggable, loggerSender } from '../../utils/logger';
import { RemoteParticipant } from '../participant/remote-participant';
import { LocalParticipant } from '../participant/local-participant';
import { filterToArray, objectToArray } from '../../utils/object-util';
import { makeArray } from '../../utils/make-array';
import { LocalVideo } from '../local/local-video';
import { LocalAudio } from '../local/local-audio';
import { LocalMedia } from '../local/local-media';
import { RemoteAudioElements } from '../remote/remote-audio-elements';
import { LocalScreen } from '../local/local-screen';
import { RoomEventName, } from '../../utils/room-event-enum';
import { ClientError } from '../../utils/error-exception';
const ConnectionStep = {
    ENTERROOM: 1,
    UPSESSION: 2,
    DOWNSESSION: 3,
    TOTALSTEP: 3
};
export class Room extends EventEmitter {
    constructor(authConfig, authResponse, config = {}) {
        super();
        this.participantMap = {}; // 참여자 아이디 - 참여자 객체
        this.receiverMap = {}; // 리시버 아이디 - 스트림 아이디 or null
        this.audioStreamIdMap = {}; // 오디오 스트림 아이디 - 참여자 아이디
        this.config = {
            videoReceiverInitialCount: 10,
            videoReceiverGrowthRate: 5,
            videoReceiverMaximumCount: 50,
            cpuOveruseDetection: true,
            maxFramerate: {
                l: 10,
                m: 20,
                h: 30
            },
            voiceMode: true,
            statInterval: 5000
        };
        this.audioOccupants = {};
        this.audioLvlUpdateTs = 0;
        this.subscribeStreamIdsQueue = [];
        this.unsubscribeStreamIdsQueue = [];
        this.streamIdsQueueInterval = -1;
        this.isStreamIdsQueueWorking = false;
        this.qualityMetricInterval = -1;
        Object.assign(this.config, config);
        logger.debug(this.config);
        this.roomApiClient = new RoomApiClient();
        this.upSession = new UpSession(this.roomApiClient, {
            cpuOveruseDetection: this.config.cpuOveruseDetection,
            maxFramerate: this.config.maxFramerate,
            voiceMode: this.config.voiceMode,
        });
        this.downSession = new DownSession(this.roomApiClient, {
            cpuOveruseDetection: this.config.cpuOveruseDetection,
            voiceMode: this.config.voiceMode,
        });
        this.localParticipant = new LocalParticipant();
        this.remoteAudioElements = new RemoteAudioElements();
        this.authConfig = authConfig;
        this.authResponse = authResponse;
        this.roomStatus = 'created';
        this.roomApiClient.on('error', (err) => {
            this._dispatch(RoomEventName.ERROR, err);
        });
        this.upSession.on('error', (err) => {
            this._dispatch(RoomEventName.ERROR, err);
        });
        this.upSession.on('RecordFailed', (msg) => {
            this._dispatch(RoomEventName.RECORDFAILED, msg);
        });
        this.downSession.on('error', (err) => {
            this._dispatch(RoomEventName.ERROR, err);
        });
        this._handleParticipantsInfo();
        this._handleReceivers();
        const apiServerUrl = this.authResponse.api;
        const httpHeaders = {
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.authResponse.token}`,
            },
        };
        this.roomApiClient.setHost(apiServerUrl);
        this.roomApiClient.setHeaders(httpHeaders);
        this.roomStatus = 'initiated';
    }
    get remoteParticipants() {
        return filterToArray(this.participantMap, p => p.id !== this.localParticipant.id);
    }
    /**
     * 미디어 서버로 부터 참여자 id를 발급받고, 세션을 생성한다.
     */
    connect(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!/^[a-zA-Z0-9-]+$/.test(roomId) || roomId.length > 32) {
                throw new ClientError(1301, '입력한 룸 id가 지원하지 않는 길이, 문자를 포함합니다.(32자 이하, 영문자/숫자/- 만 가능)');
            }
            this.roomApiClient.setRoomId(roomId);
            const res = yield this.roomApiClient.sendEnterRoom();
            this.roomApiClient.setParticipantId(res.result.participantId);
            this.localParticipant._setLocalParticipantId(res.result.participantId);
            this._dispatch(RoomEventName.CONNECTING, { progress: ConnectionStep.ENTERROOM / ConnectionStep.TOTALSTEP * 100 });
            const iceServers = this.authResponse.iceServers;
            yield this.upSession.create({ iceServers });
            this._dispatch(RoomEventName.CONNECTING, { progress: ConnectionStep.UPSESSION / ConnectionStep.TOTALSTEP * 100 });
            yield this.downSession.create({ iceServers });
            this._dispatch(RoomEventName.CONNECTING, { progress: ConnectionStep.DOWNSESSION / ConnectionStep.TOTALSTEP * 100 });
            this.roomStatus = 'connected';
            // subscribe시 큐에 저장된 streamId를 하나씩 꺼내서 assign 함
            // unsubscribe시 큐에 저장된 receiverId와 streamId를 하나씩 꺼내서 assign을 요청함
            this.streamIdsQueueInterval = window.setInterval(() => __awaiter(this, void 0, void 0, function* () {
                if (this.isStreamIdsQueueWorking === false) {
                    // unsubscribe를 먼저 수행
                    if (this.unsubscribeStreamIdsQueue.length) {
                        const lastData = this.unsubscribeStreamIdsQueue.shift();
                        if (lastData) {
                            this.isStreamIdsQueueWorking = true;
                            const pairs = lastData.pairs;
                            try {
                                yield this.downSession.assignStream(pairs);
                                let remoteVideos = [];
                                // 3. receiverMap에 stream 정보 업데이트
                                pairs.forEach(({ receiverId }) => {
                                    this.remoteParticipants.forEach((participant) => {
                                        const remoteVideo = participant.videos.find(remoteVideo => remoteVideo.receiverId === receiverId);
                                        if (remoteVideo) {
                                            remoteVideo._setReceiverId('');
                                            remoteVideo._setRemoteTrack(null);
                                            remoteVideos.push(remoteVideo);
                                        }
                                    });
                                    this.receiverMap[receiverId].streamId = null;
                                });
                                this.emit(lastData.key, remoteVideos);
                            }
                            catch (err) {
                                this.emit(lastData.key, err);
                            }
                            this.isStreamIdsQueueWorking = false;
                        }
                    }
                    else {
                        // subscribe 수행
                        if (this.subscribeStreamIdsQueue.length) {
                            const lastData = this.subscribeStreamIdsQueue.shift();
                            if (lastData) {
                                this.isStreamIdsQueueWorking = true;
                                let remoteVideos = [];
                                try {
                                    for (let streamId of lastData.streamIds) {
                                        const removeVideo = yield this._assignVideoStream([streamId]);
                                        if (removeVideo)
                                            remoteVideos = [...remoteVideos, ...removeVideo];
                                    }
                                    this.emit(lastData.key, remoteVideos);
                                }
                                catch (err) {
                                    //assign stream error
                                    this.emit(lastData.key, err);
                                }
                                this.isStreamIdsQueueWorking = false;
                            }
                        }
                    }
                }
            }), 100);
            this._startQualityMetricReport(roomId);
        });
    }
    /**
     * 생성된 세션을 제거한다.
     */
    disconnect(reason = 'disconnected') {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.roomStatus !== 'connected') {
                return logger.error('not connected.');
            }
            // subscribe, unsubscribe 타이머 및 배열 정리
            window.clearInterval(this.streamIdsQueueInterval);
            this.streamIdsQueueInterval = -1;
            // quality Metric 타이머 정리
            window.clearInterval(this.qualityMetricInterval);
            this.qualityMetricInterval = -1;
            this.isStreamIdsQueueWorking = false;
            this.unsubscribeStreamIdsQueue = [];
            this.subscribeStreamIdsQueue = [];
            this.participantMap = {};
            this.receiverMap = {};
            this.audioStreamIdMap = {};
            this.audioOccupants = {};
            this.audioLvlUpdateTs = 0;
            // 오디오 제거
            this.remoteAudioElements.detach();
            this.remoteAudioElements.stop();
            // 리모트 비디오 stop
            this.downSession.getTracks().forEach(track => track.stop());
            if (reason === 'disconnected') {
                // session destroy
                yield this.upSession.destroy();
                yield this.downSession.destroy();
            }
            else {
                this.upSession.close();
                this.downSession.close();
            }
            this.roomStatus = reason;
            this._dispatch(RoomEventName.DISCONNECTED, reason);
        });
    }
    /**
     * 내 미디어를 다른 참여자에게 공유한다.
     */
    publish(localMedias, isRecording = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (localMedias.length < 1) {
                throw new ClientError(1324, '빈 배열이 전달되었습니다.');
            }
            const promise = (media) => {
                let localAudio;
                let localVideo;
                if (media instanceof LocalMedia || media instanceof LocalScreen) {
                    localAudio = media.audio;
                    localVideo = media.video;
                }
                else if (media instanceof LocalAudio) {
                    localAudio = media;
                }
                else if (media instanceof LocalVideo) {
                    localVideo = media;
                }
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const { audioOffer, videoOffer } = yield this.upSession.addStream({
                            audioType: localAudio ? localAudio.type : 'none',
                            audioTrack: localAudio === null || localAudio === void 0 ? void 0 : localAudio.getMediaStreamTrack(),
                            audioExtraValue: localAudio === null || localAudio === void 0 ? void 0 : localAudio.extraValue,
                            videoType: localVideo ? localVideo.type : 'none',
                            localVideo: localVideo || undefined,
                            videoExtraValue: localVideo === null || localVideo === void 0 ? void 0 : localVideo.extraValue,
                            videoHd: localVideo === null || localVideo === void 0 ? void 0 : localVideo.hd,
                            record: isRecording
                        });
                        if (media instanceof LocalMedia) {
                            media._setRoom(this);
                        }
                        if (audioOffer && localAudio) {
                            localAudio._setStreamId(audioOffer.streamId, (config) => __awaiter(this, void 0, void 0, function* () {
                                yield this.upSession.configureStream([config]);
                            }));
                            this.localParticipant._setLocalAudio(localAudio);
                            this._dispatch(RoomEventName.LOCALAUDIOPUBLISHED, {
                                localAudio: localAudio
                            });
                        }
                        if (videoOffer && localVideo) {
                            localVideo._setStreamId(videoOffer.streamId, (config) => __awaiter(this, void 0, void 0, function* () {
                                yield this.upSession.configureStream([config]);
                            }));
                            this.localParticipant._setLocalVideo(localVideo);
                            this._dispatch(RoomEventName.LOCALVIDEOPUBLISHED, {
                                localVideo: localVideo
                            });
                        }
                        resolve(media);
                    }
                    catch (err) {
                        reject(err);
                    }
                }));
            };
            const promiseArr = localMedias.map(localMedia => promise(localMedia));
            try {
                yield Promise.all(promiseArr);
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * 다른 참여자에게 공유한 내 미디어를 취소한다.
     */
    unpublish(localMedias) {
        return __awaiter(this, void 0, void 0, function* () {
            const streamIds = [];
            localMedias.forEach((localMedia) => {
                if (localMedia instanceof LocalMedia || localMedia instanceof LocalScreen) {
                    localMedia.audio && streamIds.push(localMedia.audio.getStreamId());
                    localMedia.video && streamIds.push(localMedia.video.getStreamId());
                }
                else {
                    streamIds.push(localMedia.getStreamId());
                }
            });
            try {
                yield this.upSession.removeStream(streamIds);
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * 다른 참여자의 비디오를 가져온다.
     */
    subscribe(participantOrStreamIds) {
        return new Promise((resolve, reject) => {
            let unsubscribedStreamIds = [];
            if (Array.isArray(participantOrStreamIds)) {
                unsubscribedStreamIds = participantOrStreamIds;
            }
            else {
                unsubscribedStreamIds = participantOrStreamIds._getUnsubscribedStreamIds();
            }
            const intersection = this._checkAlreadySubscribe(unsubscribedStreamIds);
            if (intersection.length) {
                return reject(new ClientError(1321, '이미 구독 중인 스트림입니다. ' + intersection));
            }
            const key = Math.random().toString(36).substring(2, 12);
            this.subscribeStreamIdsQueue.push({
                key: key,
                streamIds: unsubscribedStreamIds
            });
            this.once(key, (remoteVideos) => {
                if (remoteVideos instanceof Error) {
                    return reject(remoteVideos);
                }
                //profile 기본값을 m으로 설정
                remoteVideos.forEach((remoteVideo) => {
                    remoteVideo.setQuality('m');
                });
                resolve(remoteVideos);
            });
        });
    }
    /**
     * 다른 참여자의 비디오 가져오는걸 취소한다.
     */
    unsubscribe(participantOrStreamIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const videoStreamIds = participantOrStreamIds instanceof RemoteParticipant
                    ? participantOrStreamIds._getSubscribedStreamIds()
                    : participantOrStreamIds;
                // 1. streamId로 receiverId 찾기
                const assignedStreamMap = Object.entries(this.receiverMap).reduce((streamMap, [receiverId, { type, streamId }]) => {
                    if (streamId)
                        streamMap[streamId] = { type, receiverId };
                    return streamMap;
                }, {});
                const receiverIds = [];
                videoStreamIds.forEach(streamId => {
                    if (assignedStreamMap[streamId]) {
                        receiverIds.push(assignedStreamMap[streamId].receiverId);
                    }
                });
                // @NOTE: receiver에 할당된 stream을 지우기위해 0으로 전달
                const pairs = receiverIds.map(receiverId => ({ receiverId, streamId: 0 }));
                const key = Math.random().toString(36).substring(2, 12);
                this.unsubscribeStreamIdsQueue.push({
                    key: key,
                    pairs: pairs
                });
                this.once(key, (remoteVideos) => {
                    if (remoteVideos instanceof Error) {
                        return reject(remoteVideos);
                    }
                    resolve(remoteVideos);
                });
            });
        });
    }
    getParticipant(participantId) {
        return this.participantMap[participantId] || null;
    }
    getAudioOccupants() {
        return objectToArray(this.audioOccupants);
    }
    getRemoteVideo(videoId) {
        let remoteVideo = null;
        this.remoteParticipants.some((remoteParticipant) => {
            remoteVideo = remoteParticipant.videos.find((remoteVideo) => {
                if (remoteVideo.videoId === videoId) {
                    return true;
                }
            });
            if (remoteVideo) {
                return true;
            }
        });
        return remoteVideo;
    }
    getRemoteAudio(audioId) {
        let remoteAudio = null;
        this.remoteParticipants.some((remoteParticipant) => {
            remoteAudio = remoteParticipant.audios.find((remoteVideo) => {
                if (remoteVideo.audioId === audioId) {
                    return true;
                }
            });
            if (remoteAudio) {
                return true;
            }
        });
        return remoteAudio;
    }
    _checkAlreadySubscribe(streamIds) {
        const _streamIds = Object.values(this.receiverMap).filter(({ type, streamId }) => {
            return type === 'video' && streamId !== null;
        }).map(receiver => receiver.streamId);
        const intersection = _streamIds.filter(streamId => {
            if (streamId) {
                return streamIds.includes(streamId);
            }
        });
        return intersection;
    }
    /**
     * 현재 리시버가 MAX를 초과했는지 체크한다.
     */
    _checkMaxReceiverCount() {
        const currentCount = this._getCurrentReceiverCount();
        if (currentCount >= this.config.videoReceiverMaximumCount) {
            return true;
        }
        return false;
    }
    /**
     * 현재 리시버 갯수를 반환한다.
     */
    _getCurrentReceiverCount() {
        const receiverMap = {};
        Object.entries(this.receiverMap).forEach(([key, value]) => {
            if (value.streamId) {
                receiverMap[key] = value;
            }
        });
        const receiverIds = Object.keys(receiverMap);
        const currentVideoSize = receiverIds.filter(receiverId => { var _a; return ((_a = this.downSession.getTrack(receiverId)) === null || _a === void 0 ? void 0 : _a.kind) === 'video'; }).length;
        return currentVideoSize;
    }
    /**
     * 타입별 리시버 갯수를 조절한다.
     */
    _setReceiverPool(videoSize) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._checkMaxReceiverCount())
                throw new ClientError(1322, `리시버 갯수는 maxReceiverCount를 초과할 수 없습니다.`);
            yield this.downSession.addReceiver(makeArray(videoSize, { type: 'video' }));
        });
    }
    _assignVideoStream(streamIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (streamIds.length === 0)
                throw new ClientError(1323, `빈 streamIds이 전달되었습니다.`);
            if (this._checkMaxReceiverCount())
                throw new ClientError(1322, `리시버 갯수는 maxReceiverCount를 초과할 수 없습니다.`);
            const intersection = this._checkAlreadySubscribe(streamIds);
            if (intersection.length) {
                throw new ClientError(1321, '이미 구독 중인 스트림입니다. ' + intersection);
            }
            // 1. 구독중이지 않은 streamId와 video receiverId 매핑.
            const receiverIds = Object.entries(this.receiverMap)
                .filter(([_, { type, streamId }]) => {
                return type === 'video' && streamId === null;
            })
                .map(([receiverId]) => receiverId)
                .slice(0, streamIds.length);
            // 2. 가용 리시버 체크
            if (receiverIds.length === 0 || streamIds.length > receiverIds.length) {
                //리시버 추가
                let receiverCount = this.config.videoReceiverGrowthRate;
                const currentReceiverCount = this._getCurrentReceiverCount();
                if (currentReceiverCount + this.config.videoReceiverGrowthRate > this.config.videoReceiverMaximumCount) {
                    receiverCount = this.config.videoReceiverMaximumCount - currentReceiverCount;
                }
                if (receiverCount > 0) {
                    yield this._setReceiverPool(receiverCount);
                    return yield this._assignVideoStream(streamIds);
                }
            }
            else {
                const pairs = streamIds.map((streamId, i) => {
                    return { streamId, receiverId: receiverIds[i] };
                });
                // 3. receiverMap에 stream 정보 업데이트
                pairs.forEach(({ streamId, receiverId }) => {
                    const next = Object.assign(Object.assign({}, this.receiverMap[receiverId]), { streamId });
                    this.receiverMap[receiverId] = next;
                });
                try {
                    // 4. stream과 receiver 매핑
                    yield this.downSession.assignStream(pairs);
                    let remoteVideos = [];
                    pairs.forEach(({ streamId, receiverId }) => {
                        const remoteVideoTrack = this.downSession.getTrack(receiverId);
                        if (remoteVideoTrack) {
                            const participant = Object.values(this.participantMap).find((participant) => !!participant.streamIdMap[streamId]);
                            if (participant) {
                                const remoteVideo = participant.getVideo(streamId);
                                remoteVideo._setReceiverId(receiverId, (config) => __awaiter(this, void 0, void 0, function* () {
                                    yield this.downSession.configureReceiver([config]);
                                }));
                                remoteVideo._setRemoteTrack(remoteVideoTrack);
                                remoteVideos.push(remoteVideo);
                            }
                        }
                    });
                    return remoteVideos;
                }
                catch (err) {
                    // 5. 요청 실패시 해당 receiver들을 다시 사용할 수 있도록 변경
                    pairs.forEach(({ receiverId }) => {
                        this.receiverMap[receiverId].streamId = null;
                    });
                    throw err;
                }
            }
        });
    }
    /**
     * down session에서 전달된 참여자 정보를 처리한다.
     */
    _handleParticipantsInfo() {
        const getTrackFn = (streamId) => {
            for (const receiverId in this.receiverMap) {
                if (this.receiverMap[receiverId].streamId === streamId) {
                    const found = this.downSession.getTrack(receiverId);
                    return found;
                }
            }
        };
        // TODO: 참여자 클래스 만들어서 room.participants 이런식으로 조회하기?
        this.downSession.on('ChangedParticipantsInfo', ({ change }) => {
            if (change.fullData) {
                change.fullData.forEach(({ participantId, streams }) => {
                    if (participantId !== this.localParticipant.id) {
                        this.participantMap[participantId] = new RemoteParticipant(participantId, getTrackFn, streams);
                        // @NOTE: 오디오 아이디로 참여자 아이디랑 바로 매치하기 위함
                        streams === null || streams === void 0 ? void 0 : streams.filter(stream => {
                            if (stream.media === 'audio') {
                                this.audioStreamIdMap[stream.streamId.toString()] = participantId;
                            }
                        });
                    }
                });
            }
            if (change.participantsEnter) {
                change.participantsEnter.forEach(participantId => {
                    if (participantId !== this.localParticipant.id) {
                        this.participantMap[participantId] = new RemoteParticipant(participantId, getTrackFn);
                    }
                });
                change.participantsEnter.forEach(participantId => {
                    if (participantId !== this.localParticipant.id) {
                        return this._dispatch(RoomEventName.PARTICIPANTENTERED, { remoteParticipant: this.participantMap[participantId] });
                    }
                });
            }
            if (change.participantsLeave) {
                change.participantsLeave.forEach(participantId => {
                    if (participantId !== this.localParticipant.id) {
                        delete this.participantMap[participantId];
                        return this._dispatch(RoomEventName.PARTICIPANTLEFT, { remoteParticipantId: participantId });
                    }
                });
            }
            if (change.streamsAdded) {
                change.streamsAdded.forEach((_a) => {
                    var _b;
                    var { participantId } = _a, stream = __rest(_a, ["participantId"]);
                    (_b = this.participantMap[participantId]) === null || _b === void 0 ? void 0 : _b._addStream(stream);
                    // @NOTE: 오디오 아이디로 참여자 아이디랑 바로 매치하기 위함
                    if (stream.media === 'audio') {
                        this.audioStreamIdMap[stream.streamId.toString()] = participantId;
                    }
                });
                const audioStreams = change.streamsAdded.filter(({ participantId, media }) => {
                    return participantId !== this.localParticipant.id && media === 'audio';
                });
                audioStreams.forEach(audioStream => {
                    const participant = this.participantMap[audioStream.participantId];
                    if (participant) {
                        this._dispatch(RoomEventName.REMOTEAUDIOPUBLISHED, {
                            remoteParticipant: participant,
                            remoteAudio: participant.getAudio(audioStream.streamId)
                        });
                    }
                });
                const videoStreams = change.streamsAdded.filter(({ participantId, media }) => {
                    return participantId !== this.localParticipant.id && media === 'video';
                });
                videoStreams.forEach(videoStream => {
                    const participant = this.participantMap[videoStream.participantId];
                    if (participant) {
                        const remoteVideo = participant.getVideo(videoStream.streamId);
                        this._dispatch(RoomEventName.REMOTEVIDEOPUBLISHED, {
                            remoteParticipant: participant,
                            remoteVideo: remoteVideo
                        });
                    }
                });
            }
            if (change.streamsUpdated) {
                change.streamsUpdated.forEach(({ participantId, streamId, property }) => {
                    var _a;
                    if (participantId !== this.localParticipant.id) {
                        (_a = this.participantMap[participantId]) === null || _a === void 0 ? void 0 : _a._updateStream({ streamId, property });
                        if (property.hasOwnProperty('alwaysOn')) {
                            //audio
                            const participant = this.participantMap[participantId];
                            if (participant) {
                                const remoteAudio = participant.getAudio(streamId);
                                remoteAudio._setAlwaysOn(property.alwaysOn);
                                remoteAudio._setActive(property.active);
                                this._dispatch(RoomEventName.REMOTEAUDIOSTATECHANGED, {
                                    remoteParticipant: participant,
                                    remoteAudio: remoteAudio,
                                });
                            }
                        }
                        else {
                            //video
                            const participant = this.participantMap[participantId];
                            if (participant) {
                                const remoteVideo = participant.getVideo(streamId);
                                remoteVideo._setActive(property.active);
                                this._dispatch(RoomEventName.REMOTEVIDEOSTATECHANGED, {
                                    remoteParticipant: participant,
                                    remoteVideo: remoteVideo,
                                });
                            }
                        }
                    }
                });
            }
            if (change.streamsRemoved) {
                change.streamsRemoved.forEach(({ participantId, streamId }) => {
                    if (participantId === this.localParticipant.id) {
                        const localAudio = this.localParticipant.getAudio(streamId);
                        const localVideo = this.localParticipant.getVideo(streamId);
                        if (localAudio) {
                            this._dispatch(RoomEventName.LOCALAUDIOUNPUBLISHED, {
                                localAudio: localAudio
                            });
                        }
                        if (localVideo) {
                            this._dispatch(RoomEventName.LOCALVIDEOUNPUBLISHED, {
                                localVideo: localVideo
                            });
                        }
                    }
                    else {
                        const remoteParticipant = this.participantMap[participantId];
                        if (remoteParticipant) {
                            const remoteAudio = remoteParticipant.getAudio(streamId);
                            const remoteVideo = remoteParticipant.getVideo(streamId);
                            if (remoteAudio) {
                                this._dispatch(RoomEventName.REMOTEAUDIOUNPUBLISHED, {
                                    remoteParticipant: remoteParticipant,
                                    remoteAudio: remoteAudio
                                });
                            }
                            if (remoteVideo) {
                                this._dispatch(RoomEventName.REMOTEVIDEOUNPUBLISHED, {
                                    remoteParticipant: remoteParticipant,
                                    remoteVideo: remoteVideo
                                });
                            }
                            remoteParticipant._removeStream(streamId);
                        }
                        const receiver = Object.values(this.receiverMap).find(receiver => {
                            return streamId === receiver.streamId;
                        });
                        if (receiver) {
                            receiver.streamId = null;
                        }
                    }
                });
            }
        });
        this.downSession.on('StreamChanged', ({ params }) => {
            if (params.type === 'audio') {
                const receiverId = params.receiverId;
                const streamId = params.streamId;
                const participantId = params.participantId;
                if (streamId === 0) {
                    //기존 발화자 삭제
                    const _participant = this.audioOccupants[receiverId];
                    if (_participant) {
                        const participant = this.participantMap[_participant.id];
                        const _receiverId = Object.keys(this.receiverMap).find((key) => {
                            return receiverId === key;
                        });
                        if (participant && _receiverId) {
                            //참여자의 오디오 리시버 업데이트
                            const _streamId = this.receiverMap[_receiverId].streamId;
                            if (_streamId) {
                                const remoteAudio = participant.getAudio(_streamId);
                                if (remoteAudio) {
                                    remoteAudio._setReceiverId(receiverId);
                                }
                            }
                        }
                        this._dispatch(RoomEventName.REMOTEAUDIOUNSUBSCRIBED, { remoteParticipant: participant });
                    }
                }
                else {
                    const participant = this.participantMap[participantId];
                    //참여자의 오디오 리시버 업데이트
                    if (participant) {
                        const remoteAudio = participant.getAudio(streamId);
                        if (remoteAudio) {
                            remoteAudio._setReceiverId(receiverId);
                        }
                    }
                    //새 발화자 추가
                    if (this.audioOccupants[receiverId] !== participant) {
                        this.audioOccupants[receiverId] = participant;
                        this._dispatch(RoomEventName.REMOTEAUDIOSUBSCRIBED, { remoteParticipant: participant });
                    }
                }
            }
        });
        this.downSession.on('UserMessage', (data) => {
            data.forEach((item) => {
                const senderId = item.sender;
                const message = item.message;
                const type = item.type;
                if (senderId !== this.localParticipant.id) {
                    this._dispatch(RoomEventName.USERMESSAGE, { senderId, message, type });
                }
            });
        });
        // Admin 메시지
        this.downSession.on('RoomDestroyed', () => {
            this.disconnect('destroyed');
        });
        this.downSession.on('Kick', () => {
            this.disconnect('kicked');
        });
        this.downSession.on('Inactivate', () => {
        });
    }
    _handleReceivers() {
        this.downSession.on('UpdatedReceivers', ({ name, receivers }) => __awaiter(this, void 0, void 0, function* () {
            // 리시버 아이디, 이벤트 따라 일단 저장
            // 케이스 1: 초기에 할당받은 경우
            // 케이스 2: 리시버 추가 요청 후 결과를 받는 경우
            // 케이스 3: 리시버 삭제 요청 후 결과를 받는 경우
            if (name === 'init' || name === 'add') {
                receivers.forEach(({ type, receiverId }) => {
                    this.receiverMap[receiverId] = { type, streamId: null };
                });
            }
            if (name === 'init') {
                const participants = [];
                objectToArray(this.participantMap).forEach((participant) => {
                    participants.push(participant);
                });
                const audioReceivers = this.downSession.getFixedAudioReceiver();
                this.remoteAudioElements._setReceivers(audioReceivers);
                const remoteAudioElements = this.remoteAudioElements.attach();
                remoteAudioElements.forEach(element => document.body.appendChild(element));
                yield this._setReceiverPool(this.config.videoReceiverInitialCount);
                this._dispatch(RoomEventName.CONNECTED, { remoteParticipants: participants });
            }
            if (name === 'remove') {
                receivers.forEach(({ receiverId }) => {
                    delete this.receiverMap[receiverId];
                });
            }
        }));
    }
    getRemoteAudioLevels() {
        const receivers = this.downSession.getFixedAudioReceiver();
        const levels = {
            remoteParticipants: []
        };
        let lastTimestamp = 0;
        receivers.forEach((receiver, i) => {
            const sc = receiver.getContributingSources();
            const ss = sc.find(ss => ss.timestamp > this.audioLvlUpdateTs);
            if (ss) {
                lastTimestamp = ss.timestamp;
                //remote
                const remoteParticipant = this.participantMap[this.audioStreamIdMap[ss.source]];
                if (remoteParticipant) {
                    const dBFS = Math.log10(ss.audioLevel || 0) * 20 + 3.0103;
                    let aLvl = (65 + dBFS) / 70 * 100;
                    if (aLvl > 100) {
                        aLvl = 100;
                    }
                    else if (aLvl < 0) {
                        aLvl = 0;
                    }
                    aLvl = Math.floor(aLvl);
                    levels.remoteParticipants.push({
                        remoteParticipant: remoteParticipant,
                        level: aLvl
                    });
                }
            }
        });
        if (lastTimestamp > 0) {
            this.audioLvlUpdateTs = lastTimestamp;
        }
        return levels;
    }
    switchSpeaker(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const fn = (audioElement) => {
                return new Promise((resolve, reject) => {
                    // @ts-ignore
                    audioElement.setSinkId(deviceId).then(result => resolve(result)).catch(err => reject(err));
                });
            };
            const promises = this.remoteAudioElements.audioElements.map((audioElement) => {
                return fn(audioElement);
            });
            yield Promise.all(promises);
        });
    }
    getLocalStats() {
        return __awaiter(this, void 0, void 0, function* () {
            const stats = yield this.upSession.getAllStats();
            return stats;
        });
    }
    ;
    getRemoteStats() {
        return __awaiter(this, void 0, void 0, function* () {
            const stats = yield this.downSession.getAllStats();
            return stats;
        });
    }
    ;
    _getLocalStatsReport() {
        return __awaiter(this, void 0, void 0, function* () {
            const upStats = yield this.upSession.getStats();
            const localAudioMetrics = upStats.audioStats.map((item) => {
                const track = objectToArray(this.localParticipant.audioMap).find(localAudio => localAudio.mediaStreamTrack.id === item.track.trackIdentifier);
                const oldStats = this.upSession.oldAudioStats.find((oldStat) => {
                    if (item.outboundRtp.id === oldStat.outboundRtp.id) {
                        return true;
                    }
                });
                let packetsSentPerInterval = 0;
                if (oldStats) {
                    packetsSentPerInterval = item.outboundRtp.packetsSent - oldStats.outboundRtp.packetsSent;
                }
                let bytesSentPerInterval = 0;
                if (oldStats) {
                    bytesSentPerInterval = item.outboundRtp.bytesSent - oldStats.outboundRtp.bytesSent;
                }
                return {
                    participantId: this.localParticipant.id,
                    streamId: track.streamId,
                    bytesSent: item.outboundRtp.bytesSent,
                    bytesSentPerInterval: bytesSentPerInterval,
                    packetsSent: item.outboundRtp.packetsSent,
                    packetsSentPerInterval: packetsSentPerInterval,
                    srcAudioLevel: item.mediaSource.audioLevel,
                };
            });
            this.upSession._setOldAudioStats(upStats.audioStats);
            const localVideoMetrics = upStats.videoStats.map((item) => {
                const track = objectToArray(this.localParticipant.videoMap).find((localVideo) => {
                    const videoTrack = localVideo.cloneMediaStreamTracks.find((cloneVideo) => cloneVideo.id === item.track.trackIdentifier);
                    if (videoTrack) {
                        return true;
                    }
                });
                const oldStats = this.upSession.oldVideoStats.find((oldStat) => {
                    if (item.outboundRtp.id === oldStat.outboundRtp.id) {
                        return true;
                    }
                });
                const stream = this.upSession.streamIdMidMap[track.streamId];
                let profile = 'l';
                if (stream.l === item.mid)
                    profile = 'l';
                else if (stream.m === item.mid)
                    profile = 'm';
                else if (stream.h === item.mid)
                    profile = 'h';
                let packetsSentPerInterval = 0;
                if (oldStats) {
                    packetsSentPerInterval = item.outboundRtp.packetsSent - oldStats.outboundRtp.packetsSent;
                }
                let bytesSentPerInterval = 0;
                if (oldStats) {
                    bytesSentPerInterval = item.outboundRtp.bytesSent - oldStats.outboundRtp.bytesSent;
                }
                return {
                    participantId: this.localParticipant.id,
                    streamId: track.streamId,
                    profile: profile,
                    bytesSent: item.outboundRtp.bytesSent,
                    bytesSentPerInterval: bytesSentPerInterval,
                    packetsSent: item.outboundRtp.packetsSent,
                    packetsSentPerInterval: packetsSentPerInterval,
                    framesEncoded: item.outboundRtp.framesEncoded,
                    framesSent: item.outboundRtp.framesSent,
                    pliCount: item.outboundRtp.pliCount,
                    srcFrames: item.mediaSource.frames,
                    frameWidth: item.outboundRtp.frameWidth || 0,
                    frameHeight: item.outboundRtp.frameHeight || 0,
                    framesPerSecond: item.outboundRtp.framesPerSecond || 0,
                };
            });
            this.upSession._setOldVideoStats(upStats.videoStats);
            const oldCandidatePair = this.upSession.oldCandidatePair;
            let bytesSentPerInterval = 0;
            let packetsSentPerInterval = 0;
            if (oldCandidatePair) {
                bytesSentPerInterval = (upStats.candidatePair.bytesSent || 0) - (oldCandidatePair.bytesSent || 0);
                packetsSentPerInterval = (upStats.candidatePair.packetsSent || 0) - (oldCandidatePair.packetsSent || 0);
            }
            this.upSession._setOldCandidatePairStats(upStats.candidatePair);
            return {
                audioMetrics: localAudioMetrics,
                videoMetrics: localVideoMetrics,
                bytesSentPerInterval: bytesSentPerInterval,
                packetsSentPerInterval: packetsSentPerInterval,
                currentRTT: upStats.candidatePair.currentRoundTripTime || 0,
            };
        });
    }
    _getRemoteStatsReport() {
        return __awaiter(this, void 0, void 0, function* () {
            const downStats = yield this.downSession.getStats();
            const remoteAudioMetrics = downStats.audioStats.map((item) => {
                const transceiver = this.downSession.audioTransceivers.find(audioTransceiver => {
                    return audioTransceiver.receiver.track.id === item.track.trackIdentifier;
                });
                let audio;
                this.remoteParticipants.find((participant) => {
                    audio = objectToArray(participant.audioMap).find((audioMap) => {
                        return audioMap.receiverId === (transceiver === null || transceiver === void 0 ? void 0 : transceiver.mid);
                    });
                    if (audio) {
                        return true;
                    }
                });
                const oldStats = this.downSession.oldAudioStats.find((oldStat) => {
                    if (item.inboundRtp.id === oldStat.inboundRtp.id) {
                        return true;
                    }
                });
                let packetsLostPerInterval = 0;
                if (oldStats) {
                    packetsLostPerInterval = item.inboundRtp.packetsLost - oldStats.inboundRtp.packetsLost;
                }
                let bytesReceivedPerInterval = 0;
                if (oldStats) {
                    bytesReceivedPerInterval = item.inboundRtp.bytesReceived - oldStats.inboundRtp.bytesReceived;
                }
                return {
                    participantId: audio ? audio.participantId : '',
                    receiverId: Number(item.mid),
                    streamId: audio ? audio.audioId : 0,
                    bytesReceived: item.inboundRtp.bytesReceived,
                    bytesReceivedPerInterval: bytesReceivedPerInterval,
                    totalSamplesReceived: item.inboundRtp.totalSamplesReceived,
                    audioLevel: item.inboundRtp.audioLevel,
                    packetsLost: item.inboundRtp.packetsLost,
                    packetsLostPerInterval: packetsLostPerInterval,
                };
            });
            this.downSession._setOldAudioStats(downStats.audioStats);
            const remoteVideoMetrics = downStats.videoStats.map((item) => {
                let video;
                this.remoteParticipants.some((participant) => {
                    video = objectToArray(participant.videoMap).find((remoteVideo) => {
                        return remoteVideo.mediaStreamTrack && remoteVideo.mediaStreamTrack.id === item.track.trackIdentifier;
                    });
                    if (video) {
                        return true;
                    }
                });
                const oldStats = this.downSession.oldVideoStats.find((oldStat) => {
                    if (item.inboundRtp.id === oldStat.inboundRtp.id) {
                        return true;
                    }
                });
                let packetsLostPerInterval = 0;
                if (oldStats) {
                    packetsLostPerInterval = item.inboundRtp.packetsLost - oldStats.inboundRtp.packetsLost;
                }
                let bytesReceivedPerInterval = 0;
                if (oldStats) {
                    bytesReceivedPerInterval = item.inboundRtp.bytesReceived - oldStats.inboundRtp.bytesReceived;
                }
                return {
                    participantId: video ? video.participantId : '',
                    receiverId: Number(item.mid),
                    streamId: video ? video.videoId : 0,
                    bytesReceived: item.inboundRtp.bytesReceived,
                    bytesReceivedPerInterval: bytesReceivedPerInterval,
                    framesReceived: item.inboundRtp.framesReceived,
                    framesDecoded: item.inboundRtp.framesDecoded,
                    packetsLost: item.inboundRtp.packetsLost,
                    packetsLostPerInterval: packetsLostPerInterval,
                    pliCount: item.inboundRtp.pliCount,
                    frameWidth: item.inboundRtp.frameWidth || 0,
                    frameHeight: item.inboundRtp.frameHeight || 0,
                    framesPerSecond: item.inboundRtp.framesPerSecond || 0,
                };
            });
            this.downSession._setOldVideoStats(downStats.videoStats);
            const oldCandidatePair = this.downSession.oldCandidatePair;
            let bytesReceivedPerInterval = 0;
            let packetsReceivedPerInterval = 0;
            if (oldCandidatePair) {
                bytesReceivedPerInterval = (downStats.candidatePair.bytesReceived || 0) - (oldCandidatePair.bytesReceived || 0);
                packetsReceivedPerInterval = (downStats.candidatePair.packetsReceived || 0) - (oldCandidatePair.packetsReceived || 0);
            }
            this.downSession._setOldCandidatePairStats(downStats.candidatePair);
            return {
                audioMetrics: remoteAudioMetrics,
                videoMetrics: remoteVideoMetrics,
                availableIncomingBitrate: downStats.candidatePair.availableIncomingBitrate || 0,
                bytesReceivedPerInterval: bytesReceivedPerInterval,
                packetsReceivedPerInterval: packetsReceivedPerInterval,
                currentRTT: downStats.candidatePair.currentRoundTripTime || 0,
            };
        });
    }
    _getStatsReport(localStats, remoteStats) {
        const localAudioMetrics = localStats.audioMetrics.map((audioMetrics) => {
            return {
                type: 'audio',
                streamId: audioMetrics.streamId,
                bytesSent: audioMetrics.bytesSent,
                packetsSent: audioMetrics.packetsSent,
                srcAudioLevel: audioMetrics.srcAudioLevel,
            };
        });
        const localVideoMetrics = localStats.videoMetrics.map((videoMetrics) => {
            return {
                type: 'video',
                streamId: videoMetrics.streamId,
                profile: videoMetrics.profile,
                bytesSent: videoMetrics.bytesSent,
                framesEncoded: videoMetrics.framesEncoded,
                framesSent: videoMetrics.framesSent,
                pliCount: videoMetrics.pliCount,
                srcFrames: videoMetrics.srcFrames,
            };
        });
        const remoteAudioMetrics = remoteStats.audioMetrics.map((audioMetrics) => {
            return {
                type: 'audio',
                receiverId: audioMetrics.receiverId,
                streamId: audioMetrics.streamId,
                bytesReceived: audioMetrics.bytesReceived,
                totalSamplesReceived: audioMetrics.totalSamplesReceived,
                audioLevel: audioMetrics.audioLevel,
                packetsLost: audioMetrics.packetsLost,
            };
        });
        const remoteVideoMetrics = remoteStats.videoMetrics.map((videoMetrics) => {
            return {
                type: 'video',
                receiverId: videoMetrics.receiverId,
                streamId: videoMetrics.streamId,
                bytesReceived: videoMetrics.bytesReceived,
                framesReceived: videoMetrics.framesReceived,
                framesDecoded: videoMetrics.framesDecoded,
                packetsLost: videoMetrics.packetsLost,
                pliCount: videoMetrics.pliCount,
            };
        });
        return {
            upSession: {
                audios: localAudioMetrics,
                videos: localVideoMetrics
            },
            downSession: {
                audios: remoteAudioMetrics,
                videos: remoteVideoMetrics
            }
        };
    }
    _dispatch(type, data) {
        this.emit(type, data);
    }
    sendUserMessage(targets, message, type = 'normal') {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.upSession._callSendMessage({
                targets: targets,
                message: message,
                type: type
            });
        });
    }
    _startQualityMetricReport(roomId) {
        if (loggerSender.collectionPeriod > 0) {
            let index = 0;
            this.qualityMetricInterval = window.setInterval(() => __awaiter(this, void 0, void 0, function* () {
                const localStats = yield this._getLocalStatsReport();
                const remoteStats = yield this._getRemoteStatsReport();
                const stats = this._getStatsReport(localStats, remoteStats);
                const upSessions = {
                    direction: 'up',
                    index: this.upSession.index,
                    metrics: [...stats.upSession.audios, ...stats.upSession.videos]
                };
                const downSessions = {
                    direction: 'down',
                    index: this.downSession.index,
                    metrics: [...stats.downSession.audios, ...stats.downSession.videos]
                };
                index++;
                if (index === loggerSender.collectionPeriod) {
                    const method = 'CnL.QualityMetrics';
                    const params = {
                        serviceId: this.authConfig.serviceId,
                        roomId: roomId,
                        participantId: this.localParticipant.id,
                        sessions: [upSessions, downSessions]
                    };
                    loggerSender.send({ method, params });
                    index = 0;
                }
                this._dispatch(RoomEventName.STAT, {
                    qualityStat: {
                        localQualityStat: localStats,
                        remoteQualityStat: remoteStats,
                    }
                });
            }), this.config.statInterval);
        }
    }
}
__decorate([
    Loggable('info')
], Room.prototype, "connect", null);
__decorate([
    Loggable('info')
], Room.prototype, "disconnect", null);
__decorate([
    Loggable('info')
], Room.prototype, "publish", null);
__decorate([
    Loggable('info')
], Room.prototype, "unpublish", null);
__decorate([
    Loggable('info')
], Room.prototype, "subscribe", null);
__decorate([
    Loggable('info')
], Room.prototype, "unsubscribe", null);
__decorate([
    Loggable('debug')
], Room.prototype, "getParticipant", null);
__decorate([
    Loggable('debug')
], Room.prototype, "getAudioOccupants", null);
__decorate([
    Loggable('debug')
], Room.prototype, "getRemoteVideo", null);
__decorate([
    Loggable('debug')
], Room.prototype, "getRemoteAudio", null);
__decorate([
    Loggable('info')
], Room.prototype, "_checkMaxReceiverCount", null);
__decorate([
    Loggable('info')
], Room.prototype, "_getCurrentReceiverCount", null);
__decorate([
    Loggable('debug')
], Room.prototype, "_setReceiverPool", null);
__decorate([
    Loggable('info')
], Room.prototype, "_assignVideoStream", null);
__decorate([
    Loggable('debug')
], Room.prototype, "_handleParticipantsInfo", null);
__decorate([
    Loggable('debug')
], Room.prototype, "_handleReceivers", null);
__decorate([
    Loggable('debug')
], Room.prototype, "switchSpeaker", null);
